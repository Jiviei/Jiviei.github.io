---
order: 1
title: User story as code
---

Всем привет, это снова Александр Мачулин, CPO (Chief Product Officer) компании [ics-it](https://ics-it.ru/) и сооснователь Gramax. Часто сталкиваюсь с проблемой, что, как обычно, документация кусочна и неактуальна. Сейчас набирает популярность подход Docs as Code для ведения базы знаний, который должен помочь с повышением уровня качества документации. Попробуем дополнить его ведением требований as Code и преобразованием требований в документацию.

### Когда сталкиваюсь с проблемой

Я сам анализирую и ставлю задачи на разработку в сервисе SellOut+, которому уже 6 лет. Мы столько всего сделали, что я уже не помню как некоторые функции работают и почему они вообще так были сделаны. Лезу в базу знаний -- там грустно. Возможно, я некудышный владелец продукта, конечно, но насколько мне известно плюс минус у всех такая проблема. И тут выхода два:

1. Залезть в код и посмотреть как там работает. Но там нет ответа на вопрос, почему мы год назад решили именно так сделать и какие последствия могут иметь другие решения. Надо заново анализировать.

2. Идти в таск-трекер и восстанавливать по юзер сторям как была создана функция и как она менялась во времени. Благо все изменения у нас проходят через таск-трекер и детально описываются.

Второй вариант, обычно, для меня предпочтительный. Т.к. в код залазил, когда был взрослым, сейчас я молод и лень туда лезть. Разработчиков отвлекать тоже не хочется. Выходит используем таск-трекер как базу знаний, а поиск знаний по таск-трекеру не очень эффективное занятие. Часто не удаётся найти нужные задачи, т.к. их просто много и при поиске по ключевым словам видно лишь заголовки и надо проваливаться в каждую юзер стори.

И проблема возникает, когда в команду подключаем новых коллег. У них возникает риторический вопрос “А может это где-то описано?”. На что я им отвечаю:

### Первые мысли о решении проблемы

Я озадачился вопросом, как сделать актуальную документацию. Первая приходящая на ум идея -- найти помощника аналитика или техписателя, который будет после реализации узнавать у меня и разработчиков как функция работает. У этого подхода сразу заметил  минус -- тот, кто будет этим заниматься, будет это дело не очень любить.

-  Аналитики не любят писать документацию, знаю по себе и не только.

-  Когда мы провоидили CustDev для Gramax и интервьюировали техписателей, то на вопрос “А что самое сложное в вашей работе?”, они отвечали “Изучить предметную область, а зачастую множество предметных областей, с которыми раньше не работал.”. То есть у техписателя есть дискомфорт при необходимости написать документацию. И у владельцев знаний (у меня) есть дискомфорт, т.к.  человеку не использующему и не участвующему на полный рабочий день в продукте (не делаем столько фич) необходимо в деталях рассказать как это работает и зачем, а потом ещё провести ревью написанного.

### Вторые мысли о решении проблемы

Было желание, чтобы документация появлялась без дополнительных трудозатрат с чьей-либо стороны, как в ТРИЗ. И если посмотреть на весь жизненный цикл юзер стори или эпика, то у нас есть этапы:

-  **Первоначальное пожелание.** “А давайте проверять чеки из отчётов ритейлеров через ОФД, чтобы подтверждать достоверность полученных данных.”

-  **Формализованные требования.** Юзер стори SOP-2576: Перед отправкой в ОФД, необходимо делать базовые проверки, чтобы не отправлять запросы впустую:

   -  Проверка наличия обязательных полей: FNNumber, FDNumber, FiscalSign, итоговая сумма чека. Если одного из полей нет, то блокируем загрузку отчёта.

   -  Проверка типов данных и максимальной длины содержимого в обязательных поля. Если не соответствует приложенной спецификации, то блокируем загрузку отчёта.

   -  И так далее.

-  **Документация для пользователей.** Когда загрузка отчёта ритейлера может завершиться с ошибкой и чеки не будут отправлены в ОФД, чтобы не расходовать доступные запросы:

   -  Если нет одного из обязательных полей в отчёте от ритейлера: Заводской номер фискального накопителя, Порядковый номер фискального документа, Фискальный признак документа, Итоговая сумма чека.

   -  Если значение в обязательном поле не соответствие формату, определенному в [приказе ФНС﻿](https://base.garant.ru/71640610/f7ee959fd36b5699076b35abf4f52c5c/).

   -  И так далее.

:::tip замечу

1. Документацию в стиле “Нажмите левой кнопкой мыши на кнопку, чтобы открылось диалоговое окно” мы не пишем. Нам важно отразить текущее состоянее системы, бизнес-логику и причнно-следственные связи.

2. В интерфейсе системы пользователю мы конечно же описываем по каким причинам случилась ошибка.

:::

Этапов на самом деле больше, но это не так важно. Важно то, что исходная идея о проверке чеков развивается и дополняется на каждом из этапов. Т.е. это один и тот же текст, который транформируется и дополняется по мере своей эволюции.

### Само решение

Опишу как можно внедрить данный подход на примере процессов нашей компании. Сделаю оговорку, что наша основная цель -- получить документацию для внутреннего использования. Да, она будет не самой опрятной для пользователя, но пусть она будет и будет актуальной. Позже можно будет запланировать работы по одружелюблюванию документации и это будет сделать проще, имея хороший фундамент.

#### Игридиенты

-  **Docs as Code и все сопутствующие инструменты.** Если вы не сталкивались ещё с подходом Docs as Code, то можете почитать что это такое и почему я не люблю Docs as Code в исходном виде.

-  **GitFlow/GitHubFlow.**

-  **Таск-трекер.** В идеале с возможностью интеграции с Git-хранилищем, для удобства.

Важно, чтобы в компании был хорошо налажен анализ и разработка, а именно, писались хорошие и подробные юзерстори и все доработки проходили через таск-трекер.

#### Приготовление: Шаг 1. Первая подготовка

Создаём в репозитории с кодом отдельную папку в корне `docs`. В ней будут лежать все файлы с документацией в формате .md, в нашем случае. Структура папок, на мой взгляд, не так важна на первом этапе. Надо начать  собирать информацию и постепенно будет приходить понимание о том, как лучше организовать структуру. Сесть и заранее придумать всю структуру сложно.

Удачный пример организации репозитория можно посмотреть в [GitHub VSCode.](https://github.com/microsoft/vscode-docs/tree/main/docs)

#### Шаг 2. Анализ

Предположим, что мы хотим создать новую функцию в системе.

1. Создаём задачу в таск-трекере с названием функции и описанием зачем мы хотим её создать. Также в теле юзер стори можно указать контекст, проблемы, которые привели к доработке, и другие вводные.

2. Создаём feature branch в репозитории, который можно назвать как номер заявки из таск-трекера.

3. Создаём в папке `docs` [new-feature.md](http://new-feature.md) файл, с описанием логики работы функции. Мы описываем цель, критерии приёмки и сценарии использования. Т.е. это будущее состояние системы.

4. Делаем комит в репозиторий. В сообщении комита можно указать номер заявки, тогда таск-трекер свяжет коммит с заявкой. Наш YouTrack так умеет, например. Так же из сообщения коммита можно менять статусы и другие атрибуты заявки.

Если мы хотим изменить существующую функцию, то алгоритм такой же. Юзер стори это всегда изменение текущего состояния системы к будущему. Она может менять текущее поведение системы или дополнять его. Но описываются юзер стори в формате to-be, т.е. описывают будущее состояние системы. Сравнивая [new-feature.md](http://new-feature.md) файл в feature branch и master, можем увидеть diff между двумя состояними.

Если мы хотим удалить функцию, то удаляем   [new-feature.md](http://new-feature.md)  из репозитория и проверяем нет ли на неё зависмостей из других файлов.

#### Шаг 3. Разработка

Команда разработки реализует задачу и может дополнить описание юзер стори самостоятельно в [new-feature.md](http://new-feature.md) файле. Иногда происходят уточнения информации в мессенджере и не всегда я сам могу оперативно внести эти изменения в юзер стори, тогда изменения вносит команда разработки.

#### Шаг 4. Документация

После реализации аналитик или техписатель корректирует постановку в  более удобный читателю формат и соответствующий стайлгайду. У нас этот шаг опционален, но не во всех компаиях такое допустимо.

#### Шаг 5. Публикация

1. Аналитик подтверждает, что можем публиковать доработку в прод. Аналитик также принимает решение о том, можем ли мы публиковать документацию в текущем виде на портал или её необходимо скорректировать.

2. Команда разработки делает merge в master, доработка публикуется в продакшен.

3. CI/CD обновляет static site genrator с порталом документации, который читает папку `docs` в ветке master в репозитории.

### Как на практике

С первого раза мы не смогли у себя запустить этот подход. Если кратко, то много ручной работы по синхронизации двух систем, которую не хочется делать, и множество ограничений. Если не кратко:

1. Суть концепции не смог донести до других аналитиков и заказчиков. Основные недопонимания и замечания:

   1. Зачем нам из портала документации делать таск-трекер?

   2. Ссылка из таск-трекера куда? Если в GitLab или GitHub, то это просто неудобно и у заказчиков нет туда доступа.

   3. Как заказчику проверять корректность собранных требований?

   4. Как уведомлять кого-то об изменениях? Писать комментарий в таск-трекере или в мессенджере?

2. Со стороны разработчиков также была критика, что в репозитории появится множество новых веток. Бэклог у нас может варьироваться от 5  до 100 задач, в зависимости от проекта. Не все из 100 задач детально проанализирвоаны, но во многих уже собрана первичная информация и проделана какая-то аналитическая работа. По хорошему эту работу надо также отразить на файловой системе репозитория.

И с юзер стори всё более менее понятно, а вот с эпиками -- не очень. Но у нас работает подход, когда аналитик описывает верхнеуровнево эпик, а задача разработчика -- провести декомпозицию на юзер стори и где-то даже самому побыть аналитиком и задать  неудобные вопросы аналитику по бизнес-логике и зафиксировать ответы в юзер сторях.

### Что дальше

В первом квартале 2024 года хочу реанимировать этот подход и с новыми знаниями внедрить его. Тем более, что на эту тему появляются выступления от [других компаний](https://youtu.be/vW6haSf6kug?si=815gKyhuuiqY2-RQ). И ряд вопросов по автоматизации были решены в Gramax, которые помогут повысить шансы на успех:

-  **Ссылка на ревью.** В Gramax можно сгенерировать безопасную ссылку на статью в репозитории и поделиться ссылкой с любым человеком, например, с заказчиком. При открытии ссылки у заказчика в браузере откроется каталог и скачается содержимое только той ветки, которой с ним поделились. Он сможет вносить изменения, комментировать, делать коммиты, но не сможет производить операции над веткой: удаление, мёрж, создание новой.

-  **Уведомления об изменениях.** Когда в моей ветке произошли изменения, то в десктопном приложении я получаю об это уведомления и могу посмотреть что поменялось и ответить на них. Заказчик также может бесплатно скачать себе приложение и открывать ссылку на ревью в нём. Тогда ему тоже будут приходить уведомления о миох изменениях.

Также надо подумать как объединить это с TDD (Test-Driven Development). Понятное описание того, как работает функция у нас хранится ещё и в автотестах. В нашей [статье про автоматизацию автоматизации тестирования](https://habr.com/ru/articles/766726/) можете посмтреть примеры как это работает.

### Выводы

На мой взгляд, это и есть настоящий Docs as Code, т.к.  информация о системе проходит через полный цикл разработки и именно поэтому лежит вместе с кодом. То, что обычно называют Docs as Code, обычно заключается в том, что файлы с текстами просто хранятся и версионируются в системе контроля версий. Это тоже хорошо и имеет  плюсы, которые описывали в [статье про Confluence](./../../business-plan/sale/content/habr/confluence-alternatives.md). Но задачу непрерываного обновления информации на портале документации не решает. Раз уж подходящий термин Docs as Code занят, назовём это User story as Code.

Если изобрёл велосипед или у вас есть более удачные названия, пишите в комментариях :)