---
order: 0.3
title: "!!! @SY @AL JS API"
properties:
  - name: Release
    value:
      - november-24
  - name: State
    value:
      - open
  - name: Assignee
    value:
      - SY
  - name: PO
    value:
      - AL
---

!!! поиск сделан как плагины, можно его вынести обратно и не будет такой проблемы

В чате граммах Community пользователи попросили политику расположения создания файлов сделать свою чтобы нам не делать лучше всего предоставить пользователям иметь возможность определить свое наименование по своей логике которое не захотят чтобы не делать разные политики и поддерживать их.

Хотелось бы чтобы мы взяли принцип JS API, который мы недавно добавили в MDT, и по такому же принципу максимально просто и компактно добавили бы его в Gramax.

Также почти всегда надо мириться с тем, что инструмент работает не так как пользователь привык и ожидает, даже в мелочах. Хотелось бы предоставить пользователю максимальные возможности сделать по-своему, так как ему хочется.

### Кейсы

-  **Добавить свои CSS-стили**:

   -  Убрать фон в стилях нумерованного списка

   -  Добавить внешние границы для таблицы

-  **Свои названия новых файлов**: сохранять либо в корне, либо подпапкой отдельно в каждом разделе: 1) скрины/картинки/видео -- `images/` или `media/` 2) диаграммы --  `diagrams/` 3) код -- `code/`

-  **Название статьи из заголовка первого уровня**: Наименование документа брать из названия файла (необязательно, но подумать)

-  **Свой кастомный контрол в зону**: В зону добавить баннер с кастомной картинкой и ссылкой. Референс: <https://help.loginom.ru/userguide/report/>

-   

-  В заголовке статьи чтобы можно было использовать свои элементы. Например статус или спецтеги. Фаза инициализации метаданных - обработка метаданных - рендеринг элемента (можем ли HTML-элемент передать?)

-  В левой навигации максимально просто оформлением добавить статусы и аватарки людей если захотим

-  Иметь возможность делать простые элементы на уровне абзацев. И инлайнблоков

-  Задавать атрибуты для абзацев, чтобы можно было сделать подсветку абзацев если захотят. Можно отталкиваясь от метаданных абзацев (мы думали делать в трассировке требований добавлять кастомные атрибуты к абзацам и блокам)

## Предложение по реализации

-  Для каталога (или воркспейса) возможность создать директорию `.scripts/` в которой положить свои подписчики на нужные юзеру события

-  При старте приложения (или работе с каталогом) считываются все скрипты и исполняются самым обычным образом.

-  В бизнес-логике тригерятся события и вызываются все подписчики на эти события. В том числе на создание файла артефакта. В обработчике можно переопределить название файла и путь, по которому он будет расположен, и реализовать свою логику.

Тогда при подобных запросах мы можем сказать, чтобы они на уровне воркспейса или каталога могли описать небольшой JS Handler на несколько строчек кода и все. Так же как мы это делаем в MDT.

Важно, чтобы в `d.ts` для всех функций и событий было максимально понятное описание, полное покрытие типами и примеры кода на разные ситуации.

Лучше всего, чтобы эта логика была прописана в воркспейсе на уровне организации, т.к. политика именования файлов будет привязана к воркспейсу. Также по такому же принципу в будущем мы можем дополнять правила, стайлгайды, плагины для воркспейса.

**Основной фокус**: Максимально кусочно и изолированно изменять стандартное поведение, чтобы подстраивать под свои нужды.

## Как это может выглядеть

```typescript
/// <reference path="https://app.gram.ax/typings/gramax.d.ts" />

... код скрипта
```

### Добавление своих стилей

```typescript
app.on("catalog:open", ({ catalogZones }, { fp }) => {
	const link = document.createElement('link');
	link.href = fp.getUrl('./styles.css');
	catalogZones.head.appendChild(link);
});
```

`./styles.css`:

```css
.article table { border: solid 1px var(--color-line); }
.article ol li { all: revert; }
```

### Свои названия новых файлов

Пример реализации кастомной логики, чтобы все PNG-файлы складывались в поддиректорию pngs. Нужно будет создать файл  `_scripts/main.js` с таким содержимым:

```typescript
app.on("article.resource:creating", ({ article, resource }, {  }) => {
	if (resource.getExtension() == "png") {
		resource.setFullPath(file.path, 'pngs', article.fileName); // работает по принципу path.combine, т.е. можно добавлять ../ и т.д., все лишние слеши уберутся и все отрезолвится
    } 
});
```

### Название статьи из заголовка первого уровня

```typescript
app.on("article:read", ({ article, resource }, {  }) => {
	const titleRegex = /^# (.+)$/m;
	const match = article.getContent().match(titleRegex);
	const title = match ? match[1].trim() : '';
	const contentWithoutTitle = markdown.replace(titleRegex, '').trim();
	article.setContent(contentWithoutTitle);

	article.setTitle(title);
});

app.on("article:save", ({ article, resource }, {  }) => {
	article.setContent("# " + article.getTitle() + '\r\n' + article.getContent())

	article.setTitle(null);
});
```

### Типизация

Пример файла `typings/gramax.d.ts`:

```
declare namespace GramaxJsApi {
    // важно, чтобы все названия событий были типизированы, как это сделано в MDT
	interface App { on(event: string, callback: (args: {}, services: {}) => void): void; }
}
declare const app: GramaxJsApi.App;
```

В будущем будем добавлять события и обновлять файл `d.ts`.

Еще вариант в поставку включить `tsconfig.json`, чтобы в `.gramax/` автоматически резолвились типы в VS Code без лишних `<reference... ` :

```
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ES2020",
    "checkJs": true, 
    "strict": true,
    "allowJs": true,
    "noEmit": true
  },
  "include": ["scripts/**/*.js", "typings/gramax.d.ts"] // еще есть вариант добавить
}
```